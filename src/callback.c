/*******************************************************************************
 * @file callback.c
 * @brief USB Callbacks.
 *******************************************************************************/

//=============================================================================
// src/callback.c: generated by Hardware Configurator
//
// This file is only generated if it does not exist. Modifications in this file
// will persist even if Configurator generates code. To refresh this file,
// you must first delete it and then regenerate code.
//=============================================================================
//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------

#include "usb_includes.h"

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

void
USBD_EnterHandler (void)
{

}

void
USBD_ExitHandler (void)
{

}

void
USBD_ResetCb (void)
{

}

uint8_t frames = 4;

void
USBD_SofCb (uint16_t sofNr)
{

}

void
USBD_DeviceStateChangeCb (USBD_State_TypeDef oldState,
                          USBD_State_TypeDef newState)
{
  if (newState == USBD_STATE_CONFIGURED)
  {
      usbStatus = USB_STATUS_BUSOK;
      sendReport = true;
      idleSetDuration(0);
  }
  else if (newState == USBD_STATE_ATTACHED)
  {
      //gamepadStop();
      usbStatus = USB_STATUS_ATTACHED;
  }
  else if (newState == USBD_STATE_SUSPENDED || newState == USBD_STATE_NONE)
  {
      //gamepadStop();
      sendReport = false;
      usbStatus = USB_STATUS_NOBUS;
  }
}

bool
USBD_IsSelfPoweredCb (void)
{

  return false;
}


uint8_t tmpUSBBuffer;

USB_Status_TypeDef
USBD_SetupCmdCb (SI_VARIABLE_SEGMENT_POINTER
(setup, USB_Setup_TypeDef, MEM_MODEL_SEG))
{
  USB_Status_TypeDef retVal = USB_STATUS_REQ_UNHANDLED;

    // Set up specialty items
    // for Nintendo HID
    if ((setup->bmRequestType.Type == USB_SETUP_TYPE_STANDARD)
        && (setup->bmRequestType.Direction == USB_SETUP_DIR_IN)
        && (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_INTERFACE))
    {
      // A HID device must extend the standard GET_DESCRIPTOR command
      // with support for HID descriptors.
      switch (setup->bRequest)
      {
        case GET_DESCRIPTOR:
          if ((setup->wValue >> 8) == USB_HID_REPORT_DESCRIPTOR)
          {
            switch (setup->wIndex)
            {
              case 0: // Interface 0
                switch(gamepadSubcore)
                {
                  default:
                  case (USB_SUBCORE_DINPUT):
                      USBD_Write(EP0,
                               (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))dinput_hid_descriptor,
                               EFM8_MIN(sizeof(dinput_hid_descriptor), setup->wLength),
                               false);
                      break;
                  case (USB_SUBCORE_NS):
                      USBD_Write(EP0,
                               (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))nspro_hid_descriptor,
                               EFM8_MIN(sizeof(nspro_hid_descriptor), setup->wLength),
                               false);
                      break;
                }
                retVal = USB_STATUS_OK;
                break;

              default: // Unhandled Interface
                break;
            }
          }
          else if ((setup->wValue >> 8) == USB_HID_DESCRIPTOR)
          {
            switch (setup->wIndex)
            {
              case 0: // Interface 0

                // Returns the pointer to the start
                // of the HID descriptor portion of
                // the config descriptor.
                switch(gamepadSubcore)
                {
                  default:
                  case (USB_SUBCORE_DINPUT):
                      USBD_Write(EP0,
                               (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))(&dinput_config_descriptor[18]),
                               EFM8_MIN(USB_HID_DESCSIZE, setup->wLength),
                               false);
                      break;
                  case (USB_SUBCORE_NS):
                      USBD_Write(EP0,
                               (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))(&nspro_config_descriptor[18]),
                               EFM8_MIN(USB_HID_DESCSIZE, setup->wLength),
                               false);
                      break;
                }

                retVal = USB_STATUS_OK;
                break;

              default: // Unhandled Interface
                break;
            }
          }
          break;
      }
    }

    else if ((setup->bmRequestType.Type == USB_SETUP_TYPE_CLASS)
             && (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_INTERFACE)
             && (setup->wIndex == 0))
    {
      // Implement the necessary HID class specific commands.
      switch (setup->bRequest)
      {
        case USB_HID_SET_REPORT:
          if (((setup->wValue >> 8) == 2)               // Output report
              && ((setup->wValue & 0xFF) == 0)          // Report ID
              && (setup->wLength == 1)                  // Report length
              && (setup->bmRequestType.Direction != USB_SETUP_DIR_IN))
          {
            USBD_Read(EP0, &tmpUSBBuffer, 1, true);
            retVal = USB_STATUS_OK;
          }
          break;

        case USB_HID_GET_REPORT:
          /*
          if (((setup->wValue >> 8) == 1)               // Input report
              && ((setup->wValue & 0xFF) == 0)          // Report ID
              && (setup->wLength == 8)                  // Report length
              && (setup->bmRequestType.Direction == USB_SETUP_DIR_IN))
          {

            USBD_Write(EP0,
                       (uint8_t *) &nspro_reportBuffer,
                       8,
                       false);
            retVal = USB_STATUS_OK;
          }*/
          break;

        case USB_HID_SET_IDLE:
          // Report ID
          // 0  - Idle duration applies to all report IDs
          // >0 - Idle duration applies to specified report ID only (not supported)
          /*
          if (((setup->wValue & 0xFF) == 0)
              && (setup->wLength == 0)
              && (setup->bmRequestType.Direction != USB_SETUP_DIR_IN))
          {
            // Set the idle duration in units of 4 ms
            //idleSetDuration(setup->wValue >> 8);
            retVal = USB_STATUS_OK;
          }
          */
          break;

        case USB_HID_GET_IDLE:
          /*
          if ((setup->wValue == 0)                      // Report ID
              && (setup->wLength == 1)
              && (setup->bmRequestType.Direction == USB_SETUP_DIR_IN))
          {
            tmpUSBBuffer = idleGetDuration();
            USBD_Write(EP0, &tmpUSBBuffer, 1, false);
            retVal = USB_STATUS_OK;
          }
          */
          break;
      }
    }

    return retVal;
}

bool
USBD_RemoteWakeupCb (void)
{
  // Return true if a remote wakeup event was the cause of the device
  // exiting suspend mode.
  // Otherwise return false
  return false;
}

void
USBD_RemoteWakeupDelay (void)
{
  // Delay 10 - 15 ms here

}

uint16_t
USBD_XferCompleteCb (uint8_t epAddr, USB_Status_TypeDef status,
                     uint16_t xferred, uint16_t remaining)
{
  if (epAddr == EP1IN)
  {
      sendReport = true;
  }
  return 0;
}

