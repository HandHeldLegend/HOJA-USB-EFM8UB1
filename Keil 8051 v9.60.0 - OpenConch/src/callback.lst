C51 COMPILER V9.60.0.0   CALLBACK                                                          01/12/2023 16:52:33 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE CALLBACK
OBJECT MODULE PLACED IN .\src\callback.OBJ
COMPILER INVOKED BY: C:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\Users\Mitch\S
                    -implicityStudio\v5_workspace\HOJA-USB-EFM8UB1\src\callback.c OMF2 LARGE ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZ
                    -E(9,SIZE) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM
                    -8UB1\inc;C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM8UB1\inc\config;C:/SiliconLabs/SimplicityStudio/v5/dev
                    -eloper/sdks/8051/v4.2.4//Lib/efm8_assert;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Lib/efm8_usb/inc
                    -;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Device/EFM8UB1/peripheral_driver/inc;C:/SiliconLabs/Simp
                    -licityStudio/v5/developer/sdks/8051/v4.2.4//Lib/efm8_usbc/lib_kernel/inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sd
                    -ks/8051/v4.2.4//Lib/efm8_usbc/lib_usbc_pd/inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Device/shar
                    -ed/si8051Base;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Device/EFM8UB1/inc) REGFILE(HOJA-USB-EFM8UB
                    -1.ORC) PRINT(.\src\callback.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OA OBJECT(.\src\callback.OBJ)

line level    source

   1          /*******************************************************************************
   2           * @file callback.c
   3           * @brief USB Callbacks.
   4           *******************************************************************************/
   5          
   6          //=============================================================================
   7          // src/callback.c: generated by Hardware Configurator
   8          //
   9          // This file is only generated if it does not exist. Modifications in this file
  10          // will persist even if Configurator generates code. To refresh this file,
  11          // you must first delete it and then regenerate code.
  12          //=============================================================================
  13          //-----------------------------------------------------------------------------
  14          // Includes
  15          //-----------------------------------------------------------------------------
  16          
  17          #include "usb_includes.h"
*** WARNING C318 IN LINE 11 OF C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Device/EFM8UB1/peripheral_
             -driver/inc\smb_0.h: can't open file 'efm8_config.h'
  18          
  19          //-----------------------------------------------------------------------------
  20          // Constants
  21          //-----------------------------------------------------------------------------
  22          
  23          //-----------------------------------------------------------------------------
  24          // Variables
  25          //-----------------------------------------------------------------------------
  26          
  27          //-----------------------------------------------------------------------------
  28          // Functions
  29          //-----------------------------------------------------------------------------
  30          
  31          void
  32          USBD_EnterHandler (void)
  33          {
  34   1      
  35   1      }
  36          
  37          void
  38          USBD_ExitHandler (void)
  39          {
  40   1      
  41   1      }
  42          
  43          void
  44          USBD_ResetCb (void)
  45          {
C51 COMPILER V9.60.0.0   CALLBACK                                                          01/12/2023 16:52:33 PAGE 2   

  46   1      
  47   1      }
  48          
  49          uint8_t frames = 4;
  50          
  51          void
  52          USBD_SofCb (uint16_t sofNr)
  53          {
  54   1      
  55   1      }
*** WARNING C280 IN LINE 52 OF C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM8UB1\src\callback.c: 'sofNr': un
             -referenced local variable
  56          
  57          void
  58          USBD_DeviceStateChangeCb (USBD_State_TypeDef oldState,
  59                                    USBD_State_TypeDef newState)
  60          {
  61   1        if (newState == USBD_STATE_CONFIGURED)
  62   1        {
  63   2          gamepadStatus = GAMEPAD_STATUS_READY;
  64   2          idleSetDuration(0);
  65   2        }
  66   1        else if (newState == USBD_STATE_ATTACHED)
  67   1        {
  68   2          gamepadStatus = GAMEPAD_STATUS_NOCONNECT;
  69   2        }
  70   1        else if (newState == USBD_STATE_SUSPENDED || newState == USBD_STATE_NONE)
  71   1        {
  72   2          gamepadStatus = GAMEPAD_STATUS_NOCONNECT;
  73   2        }
  74   1      }
*** WARNING C280 IN LINE 58 OF C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM8UB1\src\callback.c: 'oldState':
             - unreferenced local variable
  75          
  76          bool
  77          USBD_IsSelfPoweredCb (void)
  78          {
  79   1      
  80   1        return false;
  81   1      }
  82          
  83          
  84          
  85          uint8_t tmpUSBBuffer;
  86          
  87          USB_Status_TypeDef
  88          USBD_SetupCmdCb (SI_VARIABLE_SEGMENT_POINTER
  89          (setup, USB_Setup_TypeDef, MEM_MODEL_SEG))
  90   1      {
  91   1        USB_Status_TypeDef retVal = USB_STATUS_REQ_UNHANDLED;
  92   1      
  93   1          // Set up specialty items
  94   1          // for Nintendo HID
  95   1          if ((setup->bmRequestType.Type == USB_SETUP_TYPE_STANDARD)
  96   1              && (setup->bmRequestType.Direction == USB_SETUP_DIR_IN)
  97   1              && (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_INTERFACE))
  98   2          {
  99   2            // A HID device must extend the standard GET_DESCRIPTOR command
 100   2            // with support for HID descriptors.
 101   2            switch (setup->bRequest)
 102   3            {
 103   3              case GET_DESCRIPTOR:
 104   3                if ((setup->wValue >> 8) == USB_HID_REPORT_DESCRIPTOR)
C51 COMPILER V9.60.0.0   CALLBACK                                                          01/12/2023 16:52:33 PAGE 3   

 105   4                {
 106   4                  switch (setup->wIndex)
 107   5                  {
 108   5                    case 0: // Interface 0
 109   5                      switch(gamepadSubcore)
 110   6                      {
 111   6                        default:
 112   6                        case (USB_SUBCORE_DINPUT):
 113   6                            USBD_Write(EP0,
 114   6                                     (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))dinput_hid_descript
             -or,
 115   6                                     EFM8_MIN(sizeof(dinput_hid_descriptor), setup->wLength),
 116   6                                     false);
 117   6                            break;
 118   6                        case (USB_SUBCORE_NS):
 119   6                            USBD_Write(EP0,
 120   6                                     (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))nspro_hid_descripto
             -r,
 121   6                                     EFM8_MIN(sizeof(nspro_hid_descriptor), setup->wLength),
 122   6                                     false);
 123   6                            break;
 124   6                        case (USB_SUBCORE_XINPUT):
 125   6                            USBD_Write(EP0,
 126   6                                     (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))xinput_hid_descript
             -or,
 127   6                                     EFM8_MIN(sizeof(xinput_hid_descriptor), setup->wLength),
 128   6                                     false);
 129   6                            break;
 130   5                      }
 131   5                      retVal = USB_STATUS_OK;
 132   5                      break;
 133   5      
 134   5                    default: // Unhandled Interface
 135   5                      break;
 136   4                  }
 137   3                }
 138   3                else if ((setup->wValue >> 8) == USB_HID_DESCRIPTOR)
 139   4                {
 140   4                  switch (setup->wIndex)
 141   5                  {
 142   5                    case 0: // Interface 0
 143   5      
 144   5                      // Returns the pointer to the start
 145   5                      // of the HID descriptor portion of
 146   5                      // the config descriptor.
 147   5                      switch(gamepadSubcore)
 148   6                      {
 149   6                        default:
 150   6                        case (USB_SUBCORE_DINPUT):
 151   6                            USBD_Write(EP0,
 152   6                                     (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))(&dinput_config_des
             -criptor[18]),
 153   6                                     EFM8_MIN(USB_HID_DESCSIZE, setup->wLength),
 154   6                                     false);
 155   6                            break;
 156   6                        case (USB_SUBCORE_NS):
 157   6                            USBD_Write(EP0,
 158   6                                     (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))(&nspro_config_desc
             -riptor[18]),
 159   6                                     EFM8_MIN(USB_HID_DESCSIZE, setup->wLength),
 160   6                                     false);
 161   6                            break;
 162   6                        case (USB_SUBCORE_XINPUT):
C51 COMPILER V9.60.0.0   CALLBACK                                                          01/12/2023 16:52:33 PAGE 4   

 163   6                            USBD_Write(EP0,
 164   6                                     (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))(&xinput_config_des
             -criptor[18]),
 165   6                                     EFM8_MIN(USB_HID_DESCSIZE, setup->wLength),
 166   6                                     false);
 167   6                            break;
 168   5                      }
 169   5      
 170   5                      retVal = USB_STATUS_OK;
 171   5                      break;
 172   5      
 173   5                    default: // Unhandled Interface
 174   5                      break;
 175   4                  }
 176   3                }
 177   3                break;
 178   2            }
 179   1          }
 180   1      
 181   1          else if ((setup->bmRequestType.Type == USB_SETUP_TYPE_CLASS)
 182   1                   && (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_INTERFACE)
 183   1                   && (setup->wIndex == 0))
 184   2          {
 185   2            // Implement the necessary HID class specific commands.
 186   2            switch (setup->bRequest)
 187   3            {
 188   3              case USB_HID_SET_REPORT:
 189   3                if (((setup->wValue >> 8) == 2)               // Output report
 190   3                    && ((setup->wValue & 0xFF) == 0)          // Report ID
 191   3                    && (setup->wLength == 1)                  // Report length
 192   3                    && (setup->bmRequestType.Direction != USB_SETUP_DIR_IN))
 193   4                {
 194   4                  USBD_Read(EP0, &tmpUSBBuffer, 1, true);
 195   4                  retVal = USB_STATUS_OK;
 196   3                }
 197   3                break;
 198   3      
 199   3              case USB_HID_GET_REPORT:
 200   3                /*
 201   3                if (((setup->wValue >> 8) == 1)               // Input report
 202   3                    && ((setup->wValue & 0xFF) == 0)          // Report ID
 203   3                    && (setup->wLength == 8)                  // Report length
 204   3                    && (setup->bmRequestType.Direction == USB_SETUP_DIR_IN))
 205   3                {
 206   3      
 207   3                  USBD_Write(EP0,
 208   3                             (uint8_t *) &nspro_reportBuffer,
 209   3                             8,
 210   3                             false);
 211   3                  retVal = USB_STATUS_OK;
 212   3                }*/
 213   3                break;
 214   3      
 215   3              case USB_HID_SET_IDLE:
 216   3                // Report ID
 217   3                // 0  - Idle duration applies to all report IDs
 218   3                // >0 - Idle duration applies to specified report ID only (not supported)
 219   3                if (((setup->wValue & 0xFF) == 0)
 220   3                    && (setup->wLength == 0)
 221   3                    && (setup->bmRequestType.Direction != USB_SETUP_DIR_IN))
 222   4                {
 223   4                  // Set the idle duration in units of 4 ms
 224   4                  //idleSetDuration(setup->wValue >> 8);
C51 COMPILER V9.60.0.0   CALLBACK                                                          01/12/2023 16:52:33 PAGE 5   

 225   4                  retVal = USB_STATUS_OK;
 226   3                }
 227   3                break;
 228   3      
 229   3              case USB_HID_GET_IDLE:
 230   3                if ((setup->wValue == 0)                      // Report ID
 231   3                    && (setup->wLength == 1)
 232   3                    && (setup->bmRequestType.Direction == USB_SETUP_DIR_IN))
 233   4                {
 234   4                  tmpUSBBuffer = idleGetDuration();
 235   4                  USBD_Write(EP0, &tmpUSBBuffer, 1, false);
 236   4                  retVal = USB_STATUS_OK;
 237   3                }
 238   3                break;
 239   2            }
 240   1          }
 241   1      
 242   1          return retVal;
 243          }
 244          
 245          bool
 246          USBD_RemoteWakeupCb (void)
 247   1      {
 248   1        // Return true if a remote wakeup event was the cause of the device
 249   1        // exiting suspend mode.
 250   1        // Otherwise return false
 251   1        return false;
 252          }
 253          
 254          void
 255          USBD_RemoteWakeupDelay (void)
 256   1      {
 257   1        // Delay 10 - 15 ms here
 258   1      
 259          }
 260          
 261          uint16_t
 262          USBD_XferCompleteCb (uint8_t epAddr, USB_Status_TypeDef status,
 263                               uint16_t xferred, uint16_t remaining)
 264   1      {
 265   1        if (epAddr == EP1IN)
 266   2        {
 267   2            sendReport = true;
 268   1        }
 269   1        return 0;
*** WARNING C280 IN LINE 261 OF C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM8UB1\src\callback.c: 'status': 
             -unreferenced local variable
*** WARNING C280 IN LINE 262 OF C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM8UB1\src\callback.c: 'xferred':
             - unreferenced local variable
*** WARNING C280 IN LINE 262 OF C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM8UB1\src\callback.c: 'remaining
             -': unreferenced local variable
 270          }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1017    ----
   CONSTANT SIZE    =     29    ----
   XDATA SIZE       =      2      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   CALLBACK                                                          01/12/2023 16:52:33 PAGE 6   

   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  6 WARNING(S),  0 ERROR(S)
