C51 COMPILER V9.60.0.0   CALLBACK                                                          03/21/2023 20:03:58 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE CALLBACK
OBJECT MODULE PLACED IN .\src\callback.OBJ
COMPILER INVOKED BY: C:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\Users\Mitch\S
                    -implicityStudio\v5_workspace\HOJA-USB-EFM8UB1\src\callback.c OMF2 LARGE ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZ
                    -E(9,SIZE) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM
                    -8UB1\inc;C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM8UB1\inc\config;C:/SiliconLabs/SimplicityStudio/v5/dev
                    -eloper/sdks/8051/v4.2.4//Lib/efm8_assert;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Lib/efm8_usb/inc
                    -;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Device/EFM8UB1/peripheral_driver/inc;C:/SiliconLabs/Simp
                    -licityStudio/v5/developer/sdks/8051/v4.2.4//Lib/efm8_usbc/lib_kernel/inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sd
                    -ks/8051/v4.2.4//Lib/efm8_usbc/lib_usbc_pd/inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Device/shar
                    -ed/si8051Base;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Device/EFM8UB1/inc) REGFILE(HOJA-USB-EFM8UB
                    -1.ORC) PRINT(.\src\callback.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OA OBJECT(.\src\callback.OBJ)

line level    source

   1          /*******************************************************************************
   2           * @file callback.c
   3           * @brief USB Callbacks.
   4           *******************************************************************************/
   5          
   6          //=============================================================================
   7          // src/callback.c: generated by Hardware Configurator
   8          //
   9          // This file is only generated if it does not exist. Modifications in this file
  10          // will persist even if Configurator generates code. To refresh this file,
  11          // you must first delete it and then regenerate code.
  12          //=============================================================================
  13          //-----------------------------------------------------------------------------
  14          // Includes
  15          //-----------------------------------------------------------------------------
  16          
  17          #include "usb_includes.h"
*** WARNING C318 IN LINE 11 OF C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Device/EFM8UB1/peripheral_
             -driver/inc\smb_0.h: can't open file 'efm8_config.h'
  18          
  19          //-----------------------------------------------------------------------------
  20          // Constants
  21          //-----------------------------------------------------------------------------
  22          
  23          //-----------------------------------------------------------------------------
  24          // Variables
  25          //-----------------------------------------------------------------------------
  26          
  27          //-----------------------------------------------------------------------------
  28          // Functions
  29          //-----------------------------------------------------------------------------
  30          
  31          void
  32          USBD_EnterHandler (void)
  33          {
  34   1      
  35   1      }
  36          
  37          void
  38          USBD_ExitHandler (void)
  39          {
  40   1      
  41   1      }
  42          
  43          void
  44          USBD_ResetCb (void)
  45          {
C51 COMPILER V9.60.0.0   CALLBACK                                                          03/21/2023 20:03:58 PAGE 2   

  46   1      
  47   1      }
  48          
  49          uint8_t frames = 4;
  50          
  51          void
  52          USBD_SofCb (uint16_t sofNr)
  53          {
  54   1      
  55   1      }
*** WARNING C280 IN LINE 52 OF C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM8UB1\src\callback.c: 'sofNr': un
             -referenced local variable
  56          
  57          void
  58          USBD_DeviceStateChangeCb (USBD_State_TypeDef oldState,
  59                                    USBD_State_TypeDef newState)
  60          {
  61   1        if (newState == USBD_STATE_CONFIGURED)
  62   1        {
  63   2            usbStatus = USB_STATUS_BUSOK;
  64   2            sendReport = true;
  65   2            idleSetDuration(0);
  66   2        }
  67   1        else if (newState == USBD_STATE_ATTACHED)
  68   1        {
  69   2            //gamepadStop();
  70   2            usbStatus = USB_STATUS_ATTACHED;
  71   2        }
  72   1        else if (newState == USBD_STATE_SUSPENDED || newState == USBD_STATE_NONE)
  73   1        {
  74   2            //gamepadStop();
  75   2            sendReport = false;
  76   2            usbStatus = USB_STATUS_NOBUS;
  77   2        }
  78   1      }
*** WARNING C280 IN LINE 58 OF C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM8UB1\src\callback.c: 'oldState':
             - unreferenced local variable
  79          
  80          bool
  81          USBD_IsSelfPoweredCb (void)
  82          {
  83   1      
  84   1        return false;
  85   1      }
  86          
  87          
  88          uint8_t tmpUSBBuffer;
  89          
  90          USB_Status_TypeDef
  91          USBD_SetupCmdCb (SI_VARIABLE_SEGMENT_POINTER
  92          (setup, USB_Setup_TypeDef, MEM_MODEL_SEG))
  93   1      {
  94   1        USB_Status_TypeDef retVal = USB_STATUS_REQ_UNHANDLED;
  95   1      
  96   1          // Set up specialty items
  97   1          // for Nintendo HID
  98   1          if ((setup->bmRequestType.Type == USB_SETUP_TYPE_STANDARD)
  99   1              && (setup->bmRequestType.Direction == USB_SETUP_DIR_IN)
 100   1              && (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_INTERFACE))
 101   2          {
 102   2            // A HID device must extend the standard GET_DESCRIPTOR command
 103   2            // with support for HID descriptors.
 104   2            switch (setup->bRequest)
C51 COMPILER V9.60.0.0   CALLBACK                                                          03/21/2023 20:03:58 PAGE 3   

 105   3            {
 106   3              case GET_DESCRIPTOR:
 107   3                if ((setup->wValue >> 8) == USB_HID_REPORT_DESCRIPTOR)
 108   4                {
 109   4                  switch (setup->wIndex)
 110   5                  {
 111   5                    case 0: // Interface 0
 112   5                      switch(gamepadSubcore)
 113   6                      {
 114   6                        default:
 115   6                        case (USB_SUBCORE_DINPUT):
 116   6                            USBD_Write(EP0,
 117   6                                     (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))dinput_hid_descript
             -or,
 118   6                                     EFM8_MIN(sizeof(dinput_hid_descriptor), setup->wLength),
 119   6                                     false);
 120   6                            break;
 121   6                        case (USB_SUBCORE_NS):
 122   6                            USBD_Write(EP0,
 123   6                                     (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))nspro_hid_descripto
             -r,
 124   6                                     EFM8_MIN(sizeof(nspro_hid_descriptor), setup->wLength),
 125   6                                     false);
 126   6                            break;
 127   5                      }
 128   5                      retVal = USB_STATUS_OK;
 129   5                      break;
 130   5      
 131   5                    default: // Unhandled Interface
 132   5                      break;
 133   4                  }
 134   3                }
 135   3                else if ((setup->wValue >> 8) == USB_HID_DESCRIPTOR)
 136   4                {
 137   4                  switch (setup->wIndex)
 138   5                  {
 139   5                    case 0: // Interface 0
 140   5      
 141   5                      // Returns the pointer to the start
 142   5                      // of the HID descriptor portion of
 143   5                      // the config descriptor.
 144   5                      switch(gamepadSubcore)
 145   6                      {
 146   6                        default:
 147   6                        case (USB_SUBCORE_DINPUT):
 148   6                            USBD_Write(EP0,
 149   6                                     (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))(&dinput_config_des
             -criptor[18]),
 150   6                                     EFM8_MIN(USB_HID_DESCSIZE, setup->wLength),
 151   6                                     false);
 152   6                            break;
 153   6                        case (USB_SUBCORE_NS):
 154   6                            USBD_Write(EP0,
 155   6                                     (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))(&nspro_config_desc
             -riptor[18]),
 156   6                                     EFM8_MIN(USB_HID_DESCSIZE, setup->wLength),
 157   6                                     false);
 158   6                            break;
 159   5                      }
 160   5      
 161   5                      retVal = USB_STATUS_OK;
 162   5                      break;
 163   5      
C51 COMPILER V9.60.0.0   CALLBACK                                                          03/21/2023 20:03:58 PAGE 4   

 164   5                    default: // Unhandled Interface
 165   5                      break;
 166   4                  }
 167   3                }
 168   3                break;
 169   2            }
 170   1          }
 171   1      
 172   1          else if ((setup->bmRequestType.Type == USB_SETUP_TYPE_CLASS)
 173   1                   && (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_INTERFACE)
 174   1                   && (setup->wIndex == 0))
 175   2          {
 176   2            // Implement the necessary HID class specific commands.
 177   2            switch (setup->bRequest)
 178   3            {
 179   3              case USB_HID_SET_REPORT:
 180   3                if (((setup->wValue >> 8) == 2)               // Output report
 181   3                    && ((setup->wValue & 0xFF) == 0)          // Report ID
 182   3                    && (setup->wLength == 1)                  // Report length
 183   3                    && (setup->bmRequestType.Direction != USB_SETUP_DIR_IN))
 184   4                {
 185   4                  USBD_Read(EP0, &tmpUSBBuffer, 1, true);
 186   4                  retVal = USB_STATUS_OK;
 187   3                }
 188   3                break;
 189   3      
 190   3              case USB_HID_GET_REPORT:
 191   3                /*
 192   3                if (((setup->wValue >> 8) == 1)               // Input report
 193   3                    && ((setup->wValue & 0xFF) == 0)          // Report ID
 194   3                    && (setup->wLength == 8)                  // Report length
 195   3                    && (setup->bmRequestType.Direction == USB_SETUP_DIR_IN))
 196   3                {
 197   3      
 198   3                  USBD_Write(EP0,
 199   3                             (uint8_t *) &nspro_reportBuffer,
 200   3                             8,
 201   3                             false);
 202   3                  retVal = USB_STATUS_OK;
 203   3                }*/
 204   3                break;
 205   3      
 206   3              case USB_HID_SET_IDLE:
 207   3                // Report ID
 208   3                // 0  - Idle duration applies to all report IDs
 209   3                // >0 - Idle duration applies to specified report ID only (not supported)
 210   3                /*
 211   3                if (((setup->wValue & 0xFF) == 0)
 212   3                    && (setup->wLength == 0)
 213   3                    && (setup->bmRequestType.Direction != USB_SETUP_DIR_IN))
 214   3                {
 215   3                  // Set the idle duration in units of 4 ms
 216   3                  //idleSetDuration(setup->wValue >> 8);
 217   3                  retVal = USB_STATUS_OK;
 218   3                }
 219   3                */
 220   3                break;
 221   3      
 222   3              case USB_HID_GET_IDLE:
 223   3                /*
 224   3                if ((setup->wValue == 0)                      // Report ID
 225   3                    && (setup->wLength == 1)
 226   3                    && (setup->bmRequestType.Direction == USB_SETUP_DIR_IN))
C51 COMPILER V9.60.0.0   CALLBACK                                                          03/21/2023 20:03:58 PAGE 5   

 227   3                {
 228   3                  tmpUSBBuffer = idleGetDuration();
 229   3                  USBD_Write(EP0, &tmpUSBBuffer, 1, false);
 230   3                  retVal = USB_STATUS_OK;
 231   3                }
 232   3                */
 233   3                break;
 234   2            }
 235   1          }
 236   1      
 237   1          return retVal;
 238          }
 239          
 240          bool
 241          USBD_RemoteWakeupCb (void)
 242   1      {
 243   1        // Return true if a remote wakeup event was the cause of the device
 244   1        // exiting suspend mode.
 245   1        // Otherwise return false
 246   1        return false;
 247          }
 248          
 249          void
 250          USBD_RemoteWakeupDelay (void)
 251   1      {
 252   1        // Delay 10 - 15 ms here
 253   1      
 254          }
 255          
 256          uint16_t
 257          USBD_XferCompleteCb (uint8_t epAddr, USB_Status_TypeDef status,
 258                               uint16_t xferred, uint16_t remaining)
 259   1      {
 260   1        if (epAddr == EP1IN)
 261   2        {
 262   2            sendReport = true;
 263   1        }
 264   1        return 0;
*** WARNING C280 IN LINE 256 OF C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM8UB1\src\callback.c: 'status': 
             -unreferenced local variable
*** WARNING C280 IN LINE 257 OF C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM8UB1\src\callback.c: 'xferred':
             - unreferenced local variable
*** WARNING C280 IN LINE 257 OF C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM8UB1\src\callback.c: 'remaining
             -': unreferenced local variable
 265          }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    727    ----
   CONSTANT SIZE    =     29    ----
   XDATA SIZE       =      2      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  6 WARNING(S),  0 ERROR(S)
