C51 COMPILER V9.60.0.0   I2CBRIDGE                                                         02/05/2023 22:19:44 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE I2CBRIDGE
OBJECT MODULE PLACED IN .\src\i2cbridge.OBJ
COMPILER INVOKED BY: C:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\Users\Mitch\S
                    -implicityStudio\v5_workspace\HOJA-USB-EFM8UB1\src\i2cbridge.c OMF2 LARGE ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMI
                    -ZE(9,SIZE) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EF
                    -M8UB1\inc;C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM8UB1\inc\config;C:/SiliconLabs/SimplicityStudio/v5/de
                    -veloper/sdks/8051/v4.2.4//Lib/efm8_assert;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Lib/efm8_usb/in
                    -c;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Device/EFM8UB1/peripheral_driver/inc;C:/SiliconLabs/Sim
                    -plicityStudio/v5/developer/sdks/8051/v4.2.4//Lib/efm8_usbc/lib_kernel/inc;C:/SiliconLabs/SimplicityStudio/v5/developer/s
                    -dks/8051/v4.2.4//Lib/efm8_usbc/lib_usbc_pd/inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Device/sha
                    -red/si8051Base;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Device/EFM8UB1/inc) REGFILE(HOJA-USB-EFM8U
                    -B1.ORC) PRINT(.\src\i2cbridge.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OA OBJECT(.\src\i2cbridge.OBJ)

line level    source

   1          /*
   2           * i2c.c
   3           *
   4           *  Created on: Sep 13, 2022
   5           *      Author: Mitch
   6           */
   7          
   8          #include "i2cbridge.h"
   9          #include <stdio.h>
  10          #include <string.h>
  11          
  12          uint8_t rx_buffer[11] = {0};
  13          uint8_t rx_idx = 0;
  14          uint8_t rx_remaining = 9;
  15          
  16          bool rx_complete = false;
  17          
  18          uint8_t tx_buffer[11] = {0};
  19          uint8_t tx_idx = 0;
  20          uint8_t tx_remaining = 9;
  21          
  22          i2c_input_s i2c_input_buffer = {0};
  23          
  24          //-----------------------------------------------------------------------------
  25          // I2C0_ISR
  26          //-----------------------------------------------------------------------------
  27          //
  28          // I2C0 ISR Content goes here. Remember to clear flag bits:
  29          // I2C0STAT::I2C0INT (I2C Interrupt)
  30          //
  31          //-----------------------------------------------------------------------------
  32          SI_INTERRUPT(I2C0_ISR, I2C0_IRQn)
  33          {
  34   1        switch (I2C0STAT & I2C_STATUS_VECTOR_MASK) {
  35   2      
  36   2          case I2C_ADDR_RD:  // START+ADDR+R
  37   2            I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_RD__BMASK);
  38   2      
  39   2            tx_idx = 0;
  40   2            I2C0DOUT = tx_buffer[tx_idx];  // Write data to buffer for transmitting
  41   2            tx_idx+=1;
  42   2            break;
  43   2      
  44   2          case I2C_ADDR_WR: // START+ADDR+W
  45   2            I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_WR__BMASK);
  46   2            rx_idx = 0;
  47   2            break;
C51 COMPILER V9.60.0.0   I2CBRIDGE                                                         02/05/2023 22:19:44 PAGE 2   

  48   2      
  49   2      
  50   2          case I2C_RD_DATA:
  51   2            // Check for NACK
  52   2            if ((I2C0STAT & I2C0STAT_NACK__BMASK) == I2C0STAT_NACK__SET) {
  53   3              // Master did not NACK
  54   3              // Stopping transfer of data
  55   3              // Flush FIFO if there is data in it
  56   3              I2C0STAT &= ~I2C0STAT_NACK__BMASK;
  57   3            } else { // Prepare data for master
  58   3      
  59   3              I2C0DOUT = tx_buffer[tx_idx];
  60   3              tx_idx+=1;
  61   3      
  62   3            }
  63   2            I2C0STAT &= ~I2C0STAT_RD__BMASK;
  64   2            break;
  65   2      
  66   2          case I2C_WR_DATA:  // FIFO is full, whatever slave ACK/NACK master
  67   2            I2C0STAT &= ~I2C0STAT_WR__BMASK;
  68   2      
  69   2            break;
  70   2      
  71   2          case I2C_STOSTA:
  72   2          case I2C_STOSTARD:
  73   2            I2C0STAT &= ~I2C0STAT_STOP__BMASK;
  74   2            //
  75   2            //  STOP Condition received.
  76   2            //
  77   2            return;   // START Flag set, so re-enter ISR
  78   2            break;
  79   2      
  80   2          case I2C_STO:
  81   2            I2C0STAT &= ~I2C0STAT_STOP__BMASK;
  82   2            //
  83   2            //  STOP Condition received.
  84   2            //memset(&tx_buffer, 0, 11);
  85   2            //
  86   2            break;
  87   2          default:
  88   2            break;
  89   2        }
  90   1      
  91   1        // Poll this bit is also OK
  92   1        // while(I2C0FCT&I2C0FCT_RXCNT__FMASK) {
  93   1        while((I2C0FCN1 & I2C0FCN1_RXE__BMASK) == I2C0FCN1_RXE__NOT_EMPTY) { // Read data out
  94   2      
  95   2            rx_buffer[rx_idx]  = I2C0DIN;
  96   2      
  97   2            if (rx_idx == 0)
  98   2            {
  99   3                rx_remaining = 10;
 100   3            }
 101   2      
 102   2            rx_idx += 1;
 103   2            rx_remaining -= 1;
 104   2      
 105   2            if (rx_remaining == 0 && !rx_complete)
 106   2            {
 107   3              rx_complete = true;
 108   3              rx_idx = 0;
 109   3            }
 110   2      
C51 COMPILER V9.60.0.0   I2CBRIDGE                                                         02/05/2023 22:19:44 PAGE 3   

 111   2        }
 112   1      
 113   1        // Clear I2C interrupt flag
 114   1        I2C0STAT &= ~I2C0STAT_I2C0INT__BMASK;
 115   1      }
 116          
 117          
 118          
 119          
 120          
 121          //-----------------------------------------------------------------------------
 122          // TIMER4_ISR
 123          //-----------------------------------------------------------------------------
 124          //
 125          // TIMER4 ISR Content goes here. Remember to clear flag bits:
 126          // TMR4CN0::TF4H (Timer # High Byte Overflow Flag)
 127          // TMR4CN0::TF4L (Timer # Low Byte Overflow Flag)
 128          //
 129          //-----------------------------------------------------------------------------
 130          SI_INTERRUPT(TIMER4_ISR, TIMER4_IRQn)
 131          {
 132   1        SFRPAGE = I2CSLAVE0_PAGE;
 133   1      
 134   1        I2C0CN0 &= ~I2C0CN0_I2C0EN__BMASK;      // Disable I2C module
 135   1        I2C0CN0 |= I2C0CN0_I2C0EN__ENABLED;     // Re-enable I2C module
 136   1      
 137   1        SFRPAGE = TIMER4_PAGE;
 138   1        TMR4CN0 &= ~TMR4CN0_TF4H__BMASK;      // Clear Timer3 interrupt-pending flag
 139   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    255    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     35    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
