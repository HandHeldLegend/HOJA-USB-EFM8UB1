C51 COMPILER V9.60.0.0   GAMEPAD                                                           02/05/2023 22:19:44 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE GAMEPAD
OBJECT MODULE PLACED IN .\src\gamepad.OBJ
COMPILER INVOKED BY: C:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\Users\Mitch\S
                    -implicityStudio\v5_workspace\HOJA-USB-EFM8UB1\src\gamepad.c OMF2 LARGE ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE
                    -(9,SIZE) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM8
                    -UB1\inc;C:\Users\Mitch\SimplicityStudio\v5_workspace\HOJA-USB-EFM8UB1\inc\config;C:/SiliconLabs/SimplicityStudio/v5/deve
                    -loper/sdks/8051/v4.2.4//Lib/efm8_assert;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Lib/efm8_usb/inc;
                    -C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Device/EFM8UB1/peripheral_driver/inc;C:/SiliconLabs/Simpl
                    -icityStudio/v5/developer/sdks/8051/v4.2.4//Lib/efm8_usbc/lib_kernel/inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sdk
                    -s/8051/v4.2.4//Lib/efm8_usbc/lib_usbc_pd/inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Device/share
                    -d/si8051Base;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Device/EFM8UB1/inc) REGFILE(HOJA-USB-EFM8UB1
                    -.ORC) PRINT(.\src\gamepad.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OA OBJECT(.\src\gamepad.OBJ)

line level    source

   1          /*
   2           * gamepad.c
   3           *
   4           *  Created on: Sep 12, 2022
   5           *      Author: Mitch
   6           */
   7          
   8          #include "gamepad.h"
*** WARNING C318 IN LINE 11 OF C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.4//Device/EFM8UB1/peripheral_
             -driver/inc\smb_0.h: can't open file 'efm8_config.h'
   9          
  10          Gamepad_USB_Subcore_TypeDef gamepadSubcore = USB_SUBCORE_DINPUT;
  11          Gamepad_System_Status_TypeDef gamepadStatus = GAMEPAD_STATUS_IDLE;
  12          USB_System_Status_TypeDef usbStatus = USB_STATUS_NOBUS;
  13          bool gamepadRumble = false;
  14          bool sendReport = false;
  15          
  16          // Stop the USB mode from running if it's running
  17          void gamepadStop()
  18          {
  19   1        // Clear USB if we are already running.
  20   1        if (gamepadStatus != GAMEPAD_STATUS_IDLE)
  21   1        {
  22   2          // Stop the current USB and change the mode.
  23   2          sendReport = false;
  24   2          USBD_Stop();
  25   2          gamepadStatus = GAMEPAD_STATUS_IDLE;
  26   2        }
  27   1      }
  28          
  29          // Handle an I2C gamepad command
  30          void gamepadCmd()
  31          {
  32   1        // Check the command byte which is the first byte of the I2C rx
  33   1        switch (rx_buffer[I2C_COMMAND_IDX])
  34   1        {
  35   2          default:
  36   2          case I2C_CMD_IDLE:
  37   2            memset(&tx_buffer, 0, sizeof(tx_buffer));
  38   2            break;
  39   2      
  40   2          case I2C_CMD_STATUS:
  41   2            gamepadCheckStatus();
  42   2            break;
  43   2      
  44   2          case I2C_CMD_SETMODE:
  45   2            gamepadModeSet((I2C_Command_Setmode_TypeDef) rx_buffer[I2C_SUBCMD_IDX]);
C51 COMPILER V9.60.0.0   GAMEPAD                                                           02/05/2023 22:19:44 PAGE 2   

  46   2            break;
  47   2      
  48   2          case I2C_CMD_SETUSB:
  49   2            gamepadUSBModeSet((Gamepad_USB_Subcore_TypeDef) rx_buffer[I2C_SUBCMD_IDX]);
  50   2            break;
  51   2      
  52   2          case I2C_CMD_INPUT:
  53   2            gamepadInput();
  54   2            break;
  55   2      
  56   2          case I2C_CMD_CONFIG:
  57   2            gamepadConfigInput();
  58   2            break;
  59   2        }
  60   1      }
  61          
  62          void gamepadCheckStatus()
  63          {
  64   1        gamepadReturnCmd(I2C_RETURN_CMD_STATUS);
  65   1      }
  66          
  67          // Handle a system command. Stop, start, or reset.
  68          void gamepadModeSet(I2C_Command_Setmode_TypeDef cmd)
  69          {
  70   1        uint8_t usbret = USB_STATUS_OK;
  71   1      
  72   1        switch(cmd)
  73   1        {
  74   2            default:
  75   2            case I2C_SETMODE_STOP:
  76   2              gamepadStop();
  77   2              break;
  78   2      
  79   2            case I2C_SETMODE_START:
  80   2              gamepadStop();
  81   2      
  82   2              switch(gamepadSubcore)
  83   2              {
  84   3                default:
  85   3                    break;
  86   3      
  87   3                case USB_SUBCORE_DINPUT:
  88   3                    // Start USB
  89   3                    usbret = USBD_Init(&dinput_init_struct);
  90   3                    if (usbret != USB_STATUS_OK)
  91   3                    {
  92   4                      // Change nothing if we fail
  93   4                      return;
  94   4                    }
  95   3                    else if (usbret == USB_STATUS_OK)
  96   3                    {
  97   4                      gamepadStatus = GAMEPAD_STATUS_INITIALIZED;
  98   4                      sendReport = true;
  99   4                      return;
 100   4                    }
 101   3                    break;
 102   3      
 103   3                case USB_SUBCORE_NS:
 104   3                    // Start USB
 105   3                    usbret = USBD_Init(&nspro_init_struct);
 106   3                    if (usbret != USB_STATUS_OK)
 107   3                    {
 108   4                      // Change nothing if we fail
C51 COMPILER V9.60.0.0   GAMEPAD                                                           02/05/2023 22:19:44 PAGE 3   

 109   4                      return;
 110   4                    }
 111   3                    else if (usbret == USB_STATUS_OK)
 112   3                    {
 113   4                      gamepadStatus = GAMEPAD_STATUS_INITIALIZED;
 114   4                      sendReport = true;
 115   4                      return;
 116   4                    }
 117   3                    break;
 118   3      
 119   3                case USB_SUBCORE_XINPUT:
 120   3                    // Start USB
 121   3                    usbret = USBD_Init(&xinput_init_struct);
 122   3                    if (usbret != USB_STATUS_OK)
 123   3                    {
 124   4                      // Change nothing if we fail
 125   4                      return;
 126   4                    }
 127   3                    else if (usbret == USB_STATUS_OK)
 128   3                    {
 129   4                      gamepadStatus = GAMEPAD_STATUS_INITIALIZED;
 130   4                      sendReport = true;
 131   4                      return;
 132   4                    }
 133   3                    break;
 134   3      
 135   3                case USB_SUBCORE_GCINPUT:
 136   3                    // Start USB
 137   3                    usbret = USBD_Init(&nspro_init_struct);
 138   3                    if (usbret != USB_STATUS_OK)
 139   3                    {
 140   4                      // Change nothing if we fail
 141   4                      return;
 142   4                    }
 143   3                    else if (usbret == USB_STATUS_OK)
 144   3                    {
 145   4                      gamepadStatus = GAMEPAD_STATUS_INITIALIZED;
 146   4                      sendReport = true;
 147   4                      return;
 148   4                    }
 149   3                    break;
 150   3              }
 151   2              break;
 152   2      
 153   2            case I2C_SETMODE_RESET:
 154   2              gamepadModeSet(I2C_SETMODE_STOP);
 155   2              gamepadModeSet(I2C_SETMODE_START);
 156   2              break;
 157   2        }
 158   1      }
 159          
 160          // Set the USB Gamepad mode
 161          void gamepadUSBModeSet(Gamepad_USB_Subcore_TypeDef coreType)
 162          {
 163   1          // Make sure we are IDLE
 164   1          gamepadStop();
 165   1          gamepadSubcore = USB_SUBCORE_IDLE;
 166   1          gamepadSubcore = coreType;
 167   1      }
 168          
 169          // Send a USB Input report with gamepad data
 170          void gamepadInput()
 171          {
C51 COMPILER V9.60.0.0   GAMEPAD                                                           02/05/2023 22:19:44 PAGE 4   

 172   1        if (usbStatus != USB_STATUS_BUSOK)
 173   1        {
 174   2          return;
 175   2        }
 176   1      
 177   1        memcpy(&i2c_input_buffer, &rx_buffer[1], I2C_INPUT_SIZE);
 178   1        switch(gamepadSubcore)
 179   1        {
 180   2          default:
 181   2          case USB_SUBCORE_DINPUT:
 182   2            dinputUpdateReport();
 183   2            break;
 184   2          case USB_SUBCORE_NS:
 185   2            nsproUpdateReport();
 186   2            break;
 187   2          case USB_SUBCORE_XINPUT:
 188   2            xinputUpdateReport();
 189   2            break;
 190   2          case USB_SUBCORE_GCINPUT:
 191   2            break;
 192   2        }
 193   1      }
 194          
 195          // Send a USB Input report with config data
 196          void gamepadConfigInput()
 197          {
 198   1      
 199   1      }
 200          
 201          
 202          // Pass through config data request to I2C
 203          void gamepadReturnCmd(I2C_Return_Command_TypeDef ret_cmd)
 204          {
 205   1        // Clear TX buffer first
 206   1        memset(&tx_buffer, 0, sizeof(tx_buffer));
 207   1      
 208   1        switch(ret_cmd)
 209   1        {
 210   2          default:
 211   2            break;
 212   2      
 213   2          case I2C_RETURN_CMD_STATUS:
 214   2            tx_buffer[I2C_COMMAND_IDX] = I2C_RETURN_CMD_STATUS;
 215   2            tx_buffer[I2C_DATA_IDX] = usbStatus;
 216   2            tx_buffer[I2C_DATA_IDX+1] = gamepadStatus;
 217   2            break;
 218   2      
 219   2          case I2C_RETURN_CMD_RUMBLE:
 220   2            tx_buffer[I2C_COMMAND_IDX] = I2C_RETURN_CMD_RUMBLE;
 221   2            tx_buffer[I2C_DATA_IDX] = gamepadRumble;
 222   2            break;
 223   2        }
 224   1      
 225   1        tx_idx = 0;
 226   1        tx_remaining = 11;
 227   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    462    ----
   CONSTANT SIZE    =     29    ----
   XDATA SIZE       =      3       3
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   GAMEPAD                                                           02/05/2023 22:19:44 PAGE 5   

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
